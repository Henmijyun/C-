笔者在阅读Andrew Koening -《C陷阱和缺陷》这本书的过程中，笔者个人认为需要笔记的地方，在这里用笔记进行记录。

1.词法
🎈 = 不同于 ==
当需要对变量进行赋值，并且检查变量的新值是否为0时：
	
if(x = y)
	 
  foo();


 应该写作:
	 
if((x = y) != 0)
	 
   foo();



🎈 & 和 | 不同于 && 和 ||

🎈"贪心法"
C语言对符号的定义:每一个符号应该包含尽可能多的字符
例1：

y = x/*p;     //从/开始,后面的字符如果可以和前面组成符号,就会粘在一起,变成注释符/*


 应该写作:

y = x / *p;


 或者更清楚一点:

y = x / (*p);


例2：
	 
a+++++b
	 
a ++ + ++ b  //原本想打这样的代码
	 
a ++ ++ + b  //结果因为编译器的贪心法，会把它读成这样
	 
((a++)++)+b  //贪心法



🎈整型常量的第一个字符是数字0,那么该常量将被视为八进制数
	 
046    //这三个数格式对齐，很美观
	
047    //但是这是错误的
	 
125    //本来十进制的46，会被误认为是八进制的046



🎈单引号''括起来的一个字符表示一个整数，而双引号""括起来的一个字符代表一个指针（字符串）。
	 
'no'  //含义:无准确定义。理解:一个整数值,由'n','o'所代表的整数值按照编译器特定的定义而得到
	 
"no"  //含义：包含'n','o','\0',3个连续内存单位的首地址



🎈 /*/*/0*/**/1  利用这条公式可以知道当前编译器是否允许嵌套注释
	
/* /* /0 */ * */ 1   //值为1，允许嵌套
	
/* / */ 0* /**/ 1    //值为0*1=0，不允许嵌套



2.语法
🎄理解函数声明
ANSIC标准允许 函数的书写形式：简写为 fp(), 标准写法为：(*fp)()
因为()结合优先级高于* , *g()也就是 *(g()) ;
所以： *fp() == *(fp()) == *((*fp)())

 float (*h)();
表示h是一个指向返回值为浮点类型的函数的指针，
 (float (*)())
表示一个 “指向返回值为浮点类型的函数的指针”的 类型。

将常数0 转型为“指向返回值为void的函数的指针”类型，可以写作：
 (void(*)())0
因此，我们可以用(void(*)())0 来替换 fp ,从而得到：
 (*(void(*)())0)();
    ↓ ↓ ↓ 
//1. void(*)() - 函数指针类型
//2. (void(*)())0 - 对0进行强制类型转换，被解释为一个函数地址
//3. *(void(*)())0 - 对0地址进行了解引用操作
//4. (*(void(*)())0)() - 调用0地址处的函数
